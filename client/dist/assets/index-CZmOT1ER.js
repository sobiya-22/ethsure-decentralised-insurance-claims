import{n as d,B as l,_ as s,C as m,a as u,b as E,c as r,d as a,l as v,W as n,e as w}from"./index-B_tSOIix.js";import{f as P}from"./index-B_tSOIix.js";class N extends l{constructor(e){super(e),s(this,"connectorNamespace",m.EIP155),s(this,"currentChainNamespace",u.EIP155),s(this,"type",E.EXTERNAL),s(this,"name",void 0),s(this,"isInjected",!0),s(this,"status",r.NOT_READY),s(this,"injectedProvider",null),this.name=e.name,this.injectedProvider=e.provider,this.icon=e.icon}get provider(){return this.status!==r.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(e){throw new Error("Not implemented")}async init(e){await super.init(e);const i=this.coreOptions.chains.find(t=>t.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:i}),this.status=r.READY,this.emit(a.READY,this.name);try{if(v.debug(`initializing ${this.name} injected connector`),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId})))throw this.rehydrated=!1,n.connectionError("Failed to rehydrate.")}catch(t){this.emit(a.REHYDRATION_ERROR,t)}}async connect({chainId:e}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw n.connectionError("Injected provider is not available");const i=this.coreOptions.chains.find(t=>t.chainId===e);if(!i)throw n.connectionError("Chain config is not available");this.status=r.CONNECTING,this.emit(a.CONNECTING,{connector:this.name});try{if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==i.chainId)try{await this.switchChain(i,!0)}catch{await this.addChain(i,!0),await this.switchChain(i,!0)}this.status=r.CONNECTED;const t=h=>{if(h.length===0){var c;this.disconnect(),(c=this.injectedProvider)!==null&&c!==void 0&&c.removeListener&&this.injectedProvider.removeListener("accountsChanged",t)}};return this.injectedProvider.on("accountsChanged",t),this.emit(a.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider}),this.injectedProvider}catch(t){throw this.status=r.READY,this.rehydrated||this.emit(a.ERRORED,t),this.rehydrated=!1,t instanceof w?t:n.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(e={cleanup:!1}){if(!this.injectedProvider)throw n.connectionError("Injected provider is not available");await super.disconnectSession(),typeof this.injectedProvider.removeAllListeners<"u"&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}e.cleanup?(this.status=r.NOT_READY,this.injectedProvider=null):this.status=r.READY,await super.disconnect()}async getUserInfo(){if(this.status!==r.CONNECTED)throw n.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e,i=!1){if(!this.injectedProvider)throw n.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorerUrl],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18},iconUrls:[e.logo]}]})}async switchChain(e,i=!1){if(!this.injectedProvider)throw n.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(e,i),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}async enableMFA(){throw new Error("Method Not implemented")}async manageMFA(){throw new Error("Method Not implemented")}}const p=o=>({coreOptions:e})=>new N({name:d(o.info.name),provider:o.provider,icon:o.info.icon,coreOptions:e});export{P as createMipd,p as injectedEvmConnector};
